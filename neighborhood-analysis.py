import numpy as np
import sys
import getopt
import os


""" editable hyperparameters """
r1 = 0.00096
r2 = 0.003
r3 = 0.024
get_all = 0.1
omit_all = 0.6
num1 = 3
num2 = 1
num3 = 1


def main(argv):
    currentpath = os.getcwd()
    file_name = argv[0]
    input_name = ""
    output_name = ""

    try:
        opts, etc_args = getopt.getopt(argv[1:], "hi:o:", ["help", "input=", "output="])
    except getopt.GetoptError:
        print(file_name, "-i <input file> -o <output file>")
        sys.exit(2)

    for opt, arg in opts:
        if opt in ("-h", "--help"):
            print(file_name, "-i <input file> -o <output file>")
            print("-i format: a txt file generated by clustalo with '--distmat-out' option")
            print("-o format: a txt file containing edge information lines with space separators")
            sys.exit()
        elif opt in ("-i", "--input"):
            input_name = arg
        elif opt in ("-o", "--output"):
            output_name = arg
    if len(input_name) < 1:
        print(file_name, "-i option is mandatory")
        sys.exit(2)
    if not os.path.exists(input_name):
        print(f"{input_name} not exists")
        sys.exit(2)

    print(currentpath, file_name, input_name, output_name)

    """ import the pairwise distance matrix info """
    print("importing...")
    accessions = np.array([])
    pdm = np.array([])
    with open(rf'{input_name}', 'r') as f:
        count = 1
        for i in f:
            if count == 1:
                length = int(i)
                accessions = np.full((length, 1), '----------------------')
                pdm = np.zeros((length, length))
            else:
                accessions[count - 2] = np.array(i[:i.find(' ')])
                pdm[count - 2] = np.array(i[i.find(' '):].lstrip().rstrip('\n').split(), dtype='float64')
            count += 1

    """ Nearest neighbor analysis """

    processeddata = set([])
    count1 = 0
    for i in pdm:
        print(f"{count1 + 1}/{length}")
        fff = np.sort(i)
        count2 = 0
        """ histogram profiling """
        interval = (fff[-1] - fff[0]) / 100
        container1 = []
        container2 = []
        container3 = []
        switch0, switch1 = 0, 0
        for bins in range(100)[1:]:
            num = len(np.intersect1d(np.where(fff >= (bins - 1) * interval), np.where(bins * interval > fff)))
            if num >= length * r3:
                container1.append(bins * interval)
                container2.append(bins * interval)
                container3.append(bins * interval)
            if num >= length * r2:
                if switch1 == 0:
                    container1.append(bins * interval)
                    container2.append(bins * interval)
                    switch1 += 1
            if num >= length * r1:
                if switch0 == 0:
                    container1.append(bins * interval)
                    switch0 += 1
        cutoff1 = container1[0]
        cutoff2 = container2[0]
        cutoff3 = container3[0]

        """ cutoff the network """

        def getneighboratdistance():
            """ get all neighbors at a specific distance"""
            for k in np.where(i == j):
                for element in k:
                    processeddata.add(str(accessions[count1, 0]) + " relates " + str(accessions[element, 0] + " " + str(j)))

        for j in fff:
            if j < get_all:
                getneighboratdistance()
            elif j > omit_all:
                break
            elif j <= cutoff1:
                if count2 <= num1:
                    getneighboratdistance()
                else:
                    break
            elif j <= cutoff2:
                if count2 <= num2:
                    getneighboratdistance()
                else:
                    break
            elif j <= cutoff3:
                if count2 <= num3:
                    getneighboratdistance()
                else:
                    break
            else:
                break
            count2 += 1
        count1 += 1

    """ create an output file """
    lines = ['SourceNode InteractionType TargetNode EdgeAttribute'] + list(processeddata)
    result = '\n'.join(lines)
    if output_name != "":
        with open(rf'{output_name}', 'w') as f:
            f.write(result)
        print(f'{output_name} was generated')
    else:
        if input_name[-4:] == ".txt":
            with open(rf'{".".join(input_name.split(".")[:-1])}-edges.txt', 'w') as f:
                f.write(result)
        else:
            with open(rf'{input_name}-edges.txt', 'w') as f:
                f.write(result)
        print(f'{input_name}-edges.txt was generated')


if __name__ == "__main__":
    main(sys.argv)
